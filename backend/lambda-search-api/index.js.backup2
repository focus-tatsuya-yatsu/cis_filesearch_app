/**
 * Dual Index Search API Lambda Function with IAM Authentication
 * Supports both text search (cis-files) and image search (file-index-v2-knn)
 * Also supports image embedding generation via Bedrock
 */

const AWS = require('aws-sdk');
const https = require('https');
const crypto = require('crypto');
const { BedrockRuntimeClient, InvokeModelCommand } = require('@aws-sdk/client-bedrock-runtime');

AWS.config.update({
  region: process.env.AWS_REGION || 'ap-northeast-1',
  credentials: new AWS.EnvironmentCredentials('AWS')
});

async function generateImageEmbedding(imageBase64) {
  const client = new BedrockRuntimeClient({ region: 'us-east-1' });
  const command = new InvokeModelCommand({
    modelId: 'amazon.titan-embed-image-v1',
    contentType: 'application/json',
    accept: 'application/json',
    body: JSON.stringify({ inputImage: imageBase64 })
  });
  const response = await client.send(command);
  const result = JSON.parse(new TextDecoder().decode(response.body));
  return result.embedding;
}

class AWSSignerV4 {
  constructor(credentials, region, service) {
    this.credentials = credentials;
    this.region = region;
    this.service = service;
  }

  async sign(request) {
    const credentials = await this.getCredentials();
    const datetime = new Date().toISOString().replace(/[:-]|\.\d{3}/g, '');
    const date = datetime.substring(0, 8);
    request.headers = request.headers || {};
    request.headers['Host'] = request.hostname;
    request.headers['X-Amz-Date'] = datetime;
    if (credentials.sessionToken) {
      request.headers['X-Amz-Security-Token'] = credentials.sessionToken;
    }
    request.body = request.body || '';
    const canonicalRequest = this.createCanonicalRequest(request);
    const stringToSign = this.createStringToSign(datetime, date, canonicalRequest);
    const signature = this.calculateSignature(credentials.secretAccessKey, date, stringToSign);
    request.headers['Authorization'] = `AWS4-HMAC-SHA256 Credential=${credentials.accessKeyId}/${date}/${this.region}/${this.service}/aws4_request, SignedHeaders=${this.getSignedHeaders(request.headers)}, Signature=${signature}`;
    return request;
  }

  async getCredentials() {
    return new Promise((resolve, reject) => {
      this.credentials.get((err) => {
        if (err) reject(err);
        else resolve({ accessKeyId: this.credentials.accessKeyId, secretAccessKey: this.credentials.secretAccessKey, sessionToken: this.credentials.sessionToken });
      });
    });
  }

  createCanonicalRequest(request) {
    const method = request.method || 'GET';
    const path = request.path || '/';
    const headers = this.getCanonicalHeaders(request.headers);
    const signedHeaders = this.getSignedHeaders(request.headers);
    const hashedPayload = this.hash(request.body || '');
    return `${method}\n${path}\n\n${headers}\n${signedHeaders}\n${hashedPayload}`;
  }

  getCanonicalHeaders(headers) {
    return Object.keys(headers).map(k => k.toLowerCase()).sort().map(k => {
      const orig = Object.keys(headers).find(x => x.toLowerCase() === k);
      return `${k}:${String(headers[orig]).trim()}`;
    }).join('\n') + '\n';
  }

  getSignedHeaders(headers) {
    return Object.keys(headers).map(k => k.toLowerCase()).sort().join(';');
  }

  createStringToSign(datetime, date, canonicalRequest) {
    return `AWS4-HMAC-SHA256\n${datetime}\n${date}/${this.region}/${this.service}/aws4_request\n${this.hash(canonicalRequest)}`;
  }

  calculateSignature(secretAccessKey, date, stringToSign) {
    const kDate = this.hmac(`AWS4${secretAccessKey}`, date);
    const kRegion = this.hmac(kDate, this.region);
    const kService = this.hmac(kRegion, this.service);
    const kSigning = this.hmac(kService, 'aws4_request');
    return this.hmac(kSigning, stringToSign, 'hex');
  }

  hash(data) { return crypto.createHash('sha256').update(data, 'utf8').digest('hex'); }
  hmac(key, data, enc = null) { const h = crypto.createHmac('sha256', key); h.update(data, 'utf8'); return enc ? h.digest(enc) : h.digest(); }
}

class OpenSearchClient {
  constructor(endpoint) {
    this.endpoint = endpoint.replace(/^https?:\/\//, '');
    this.signer = new AWSSignerV4(new AWS.EnvironmentCredentials('AWS'), process.env.AWS_REGION || 'ap-northeast-1', 'es');
  }

  async request(method, path, body = null) {
    const options = { hostname: this.endpoint, port: 443, path, method, headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' }, body: body || '' };
    if (body) options.headers['Content-Length'] = Buffer.byteLength(body);
    await this.signer.sign(options);
    return new Promise((resolve, reject) => {
      const req = https.request(options, (res) => {
        let data = '';
        res.on('data', (chunk) => { data += chunk; });
        res.on('end', () => {
          if (res.statusCode >= 200 && res.statusCode < 300) {
            try { resolve(JSON.parse(data)); } catch (e) { resolve(data); }
          } else { reject(new Error(`OpenSearch error: ${res.statusCode} - ${data}`)); }
        });
      });
      req.on('error', reject);
      if (body) req.write(body);
      req.end();
    });
  }

  async search(index, query) { return this.request('POST', `/${index}/_search`, JSON.stringify(query)); }
}

exports.handler = async (event) => {
  console.log('Lambda started:', JSON.stringify(event));
  const corsHeaders = { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Methods': 'GET, POST, OPTIONS', 'Access-Control-Allow-Headers': 'Content-Type' };
  const httpMethod = event.httpMethod || event.requestContext?.http?.method || 'GET';
  
  if (httpMethod === 'OPTIONS') return { statusCode: 200, headers: corsHeaders, body: '' };

  try {
    let params = httpMethod === 'POST' && event.body ? JSON.parse(event.body) : (event.queryStringParameters || {});

    // Handle embedding generation
    if (params.action === 'generate-embedding') {
      console.log('Generating embedding...');
      if (!params.image) return { statusCode: 400, headers: corsHeaders, body: JSON.stringify({ success: false, error: 'Image required' }) };
      const embedding = await generateImageEmbedding(params.image);
      console.log(`Generated ${embedding.length}D embedding`);
      return { statusCode: 200, headers: corsHeaders, body: JSON.stringify({ success: true, data: { embedding, dimensions: embedding.length } }) };
    }

    // Handle search
    const { q, query: qry, searchType, imageVector, page = 1, limit = 20, sortBy = 'relevance', sortOrder = 'desc', searchMode = 'or' } = params;
    const searchQuery = q || qry || '';
    const endpoint = process.env.OPENSEARCH_ENDPOINT;
    if (!endpoint) throw new Error('OPENSEARCH_ENDPOINT required');
    
    const client = new OpenSearchClient(endpoint);
    let indexName, searchBody;

    if (searchType === 'image' && imageVector) {
      indexName = 'file-index-v2-knn';
      searchBody = { size: limit, from: (page - 1) * limit, query: { knn: { image_embedding: { vector: imageVector, k: Math.min(limit * 2, 100) } } }, _source: ['file_name', 'file_path', 'file_type', 'file_size', 'modified_date', 'department', 'tags'] };
    } else {
      indexName = 'cis-files';
      const queryObj = !searchQuery.trim() ? { match_all: {} } : { bool: { should: [{ multi_match: { query: searchQuery, fields: ['file_name^3', 'content^2', 'file_path'], operator: searchMode === 'and' ? 'and' : 'or' } }, { wildcard: { file_name: { value: `*${searchQuery}*`, boost: 2 } } }], minimum_should_match: 1 } };
      searchBody = { size: limit, from: (page - 1) * limit, query: queryObj, highlight: { fields: { content: { fragment_size: 150, number_of_fragments: 1 }, file_name: {} } }, _source: ['file_name', 'file_path', 'file_type', 'file_size', 'created_date', 'modified_date', 'department', 'tags', 'content'] };
      if (sortBy === 'date') searchBody.sort = [{ modified_date: { order: sortOrder, missing: '_last' } }];
      else if (sortBy === 'size') searchBody.sort = [{ file_size: { order: sortOrder } }];
      else if (sortBy === 'name') searchBody.sort = [{ 'file_name.keyword': { order: sortOrder } }];
    }

    const response = await client.search(indexName, searchBody);
    const results = response.hits.hits.map(hit => ({
      id: hit._id,
      fileName: hit._source.fileName || hit._source.file_name,
      filePath: hit._source.filePath || hit._source.file_path,
      fileType: hit._source.fileType || hit._source.file_type,
      fileSize: hit._source.fileSize || hit._source.file_size,
      modifiedDate: hit._source.modifiedDate || hit._source.modified_date,
      department: hit._source.department,
      tags: hit._source.tags,
      snippet: hit.highlight?.content?.[0] || hit._source.content?.substring(0, 200),
      relevanceScore: hit._score,
      highlights: hit.highlight || {}
    }));
    const total = typeof response.hits.total === 'object' ? response.hits.total.value : response.hits.total;

    return { statusCode: 200, headers: corsHeaders, body: JSON.stringify({ success: true, data: { results, total, page: parseInt(page), limit: parseInt(limit), searchType: searchType || 'text', index: indexName } }) };
  } catch (error) {
    console.error('Error:', error);
    return { statusCode: 500, headers: corsHeaders, body: JSON.stringify({ success: false, error: error.message }) };
  }
};
